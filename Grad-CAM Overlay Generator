import torch
import numpy as np
import cv2
from PIL import Image
import os

def generate_gradcam_overlay(model, input_tensor, image_path):
    # Hook the last conv layer
    final_conv = None
    for name, module in model.named_modules():
        if isinstance(module, torch.nn.Conv2d):
            final_conv = module

    gradients = []
    activations = []

    def forward_hook(module, input, output):
        activations.append(output)

    def backward_hook(module, grad_in, grad_out):
        gradients.append(grad_out[0])

    handle_fwd = final_conv.register_forward_hook(forward_hook)
    handle_bwd = final_conv.register_backward_hook(backward_hook)

    output = model(input_tensor)
    class_idx = torch.argmax(output, dim=1)
    model.zero_grad()
    output[0, class_idx].backward()

    handle_fwd.remove()
    handle_bwd.remove()

    grad = gradients[0].squeeze().cpu().numpy()
    act = activations[0].squeeze().cpu().numpy()

    weights = np.mean(grad, axis=(1, 2))
    cam = np.zeros(act.shape[1:], dtype=np.float32)

    for i, w in enumerate(weights):
        cam += w * act[i]

    cam = np.maximum(cam, 0)
    cam = cv2.resize(cam, (224, 224))
    cam -= cam.min()
    cam /= cam.max()

    heatmap = cv2.applyColorMap(np.uint8(255 * cam), cv2.COLORMAP_JET)
    original = cv2.imread(image_path)
    original = cv2.resize(original, (224, 224))
    overlay = cv2.addWeighted(original, 0.5, heatmap, 0.5, 0)

    overlay_path = f"overlays/gradcam_{os.path.basename(image_path)}"
    os.makedirs("overlays", exist_ok=True)
    cv2.imwrite(overlay_path, overlay)

    return overlay_path
